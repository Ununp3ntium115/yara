# Cryptex Dictionary â€” Anarchist Seed Set

First pass at branding core YARA entry points with anarchist-style codenames. Each row captures the upstream symbol, where it lives, and quick pseudocode so we can iteratively cover the entire project.

| Codename | Symbol | Location | Summary | Pseudocode |
| --- | --- | --- | --- | --- |
| **BlackFlag-Bootstrap** | `yr_initialize` | `libyara/include/yara/libyara.h` | Initializes global allocators, module registry, and thread primitives before any compiler/scanner work. | ```if runtime_already_init: return OK; zero_global_state(); init_arenas(); init_modules(); register_builtin_modules(); return status``` |
| **BlackFlag-LastLight** | `yr_finalize` | `libyara/include/yara/libyara.h` | Tears down libyara state, releasing arenas, mutexes, and module tables. | ```if runtime_not_init: return ERROR; unload_modules(); destroy_mutexes(); free_arenas(); set_runtime_flag(False);``` |
| **Cell-Tactician** | `yr_set_configuration_uint32/uint64` | `libyara/include/yara/libyara.h` | Applies runtime tunables (stack depth, max strings, match data). | ```switch(config_name): case STACK_SIZE: runtime.stack = value; case MAX_STRINGS: runtime.max_strings = value; ...; return OK``` |
| **InkSlinger-Compiler** | `yr_compiler_add_file` | `libyara/compiler.c` | Feeds a rule file into the compiler, wiring lexer/parser to build bytecode in the arena. | ```handle = open_file(path); while tokens := lex(handle): parse(tokens, compiler_ctx); on_error -> compiler->last_error = ...; return status``` |
| **Molotov-SweepFile** | `yr_rules_scan_file` | `libyara/rules.c` | Maps a target file and streams it through the VM against compiled rules, invoking callbacks on matches. | ```if not rules.ready: return ERROR; for each chunk in file: scan_chunk_with_vm(chunk, scanner_ctx); finalize_matches(callback);``` |
| **Molotov-SweepMemory** | `yr_rules_scan_mem` | `libyara/rules.c` | Runs compiled rules against an in-memory buffer (already loaded sample or process chunk). | ```scanner = acquire_scanner(rules); scanner.set_callback(cb); scan_buffer(bytes, size); release_scanner(scanner);``` |
| **Molotov-SweepProcess** | `yr_rules_scan_proc` | `libyara/proc/linux.c` et al. | Attaches to a live process (platform-specific backend), walks memory chunks, and streams them through the VM. | ```handle = open_process(pid); while chunk := read_process_memory(handle): scanner.scan(chunk); on_error -> break; close_handle(handle);``` |
| **DeadDrop-Callback** | `yr_scanner_set_callback` | `libyara/scanner.c` | Registers the function invoked whenever a rule matches, supplying rule metadata to higher layers. | ```scanner->callback = fn; scanner->user_data = ctx; return OK;``` |
| **Cathedral-Broadcast** | `cli/yara.c:main` | `cli/yara.c` | CLI entry point that parses flags, loads rules (either from source or compiled form), iterates over targets, and prints matches. | ```parse_args(); rules = compile_or_load(); for each target in argv: result = yr_rules_scan_file(...); report(result); return exit_code;``` |
| **Switchblade-SafeIndex** | `create_safe_rules.py:create_safe_index` | `create_safe_rules.py` | Generates `safe_malware_index.yar` by skipping rule files that reference the `cuckoo` module. | ```for include in malware_index: path = base/include; if has_text(path, "cuckoo."): log_skip(); else append_to_safe_index(); write_header(); flush_lines();``` |
| **Streetlight-Sweep** | `yara_scanner.py:YaraScanner.scan_directory` | `yara_scanner.py` | Walks a directory, compiles the configured rules once, filters files by extension/size, and records matches to JSON. | ```for file in glob(directory, recursive): if extensions && suffix not match: continue; if size > 100MB: continue; if rules.match(file): record_match(file, metadata); if count % 100 == 0: log_progress();``` |
| **IronCurtain-PEProbe** | `modules/pe/module.c:module_load` | `libyara/modules/pe` | Parses PE headers (sections, imports, signatures) and exposes them to YARA rules via the `pe` module. | ```pe = pe_parse(context); if !pe: return ERROR; set_structure_fields(module_object, pe); register_resources(); return OK;``` |
| **IronCurtain-Signature** | `modules/pe/authenticode.c:pe_verify_signature` | `libyara/modules/pe` | Validates Authenticode signatures and surfaces certificate metadata. | ```digest = hash_pe_contents(pe); cert = parse_pkcs7(pe); if verify(cert, digest): expose_cert_fields(); else raise MODULE_ERROR;``` |
| **Ghostwire-Embed** | `docs/writingrules.rst` (rule embed examples) | `docs/writingrules.rst` | Documentation section teaching how to embed strings/hex for detection. | ```Explain: strings: $a = "foo"; hex: $b = { 6A ?? 00 }; condition: $a or $b;``` |
| **SignalFire-DocsIndex** | `docs/index.rst` | `docs/index.rst` | Sphinx root that stitches the doc tree (getting started, modules, API). | ```.. toctree:: maxdepth=2 -> gettingstarted, commandline, modules, writingrules, ...``` |

Next steps: continue harvesting additional symbols (scanner callbacks, module loaders, CLI commands, Sphinx docs) until every meaningful surface has an anarchist codename and pseudocode stub.

